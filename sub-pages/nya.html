<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nya Bookmarklet</title>
    <link rel="stylesheet" href="../css/sub-pages.css">
    <link rel="shortcut icon" href="../assets/icon.ico" type="image/x-icon">
    <script src="../scripts/main.js" defer></script>
</head>
<body>
    <h1>
        Nya
    </h1>
    <main>

        <div>
            <p class="description">
            </p>
        </div>
        <fieldset id="navigation">
            <legend>Navigation</legend>
            <ul>
                <li>
                    <a href="../index.html" id="home_btn">Home&nbsp;page</a>
                    <br>
                    <br>
                </li>
                
                <li>
                    <a href="#raw_code_section">Raw code</a>
                </li>
                <li>
                    <a href="#readable_code_section">Readable code</a>
                </li>
                <li>
                    <a href="#bookmark_section">Bookmark</a>
                </li>
            </ul>
        </fieldset>
        <p class="mobile-mode">Reading the code in mobile isn't the best But you can turn on Desktop mode it might help.</p>
        <h3 id="raw_code_section">Raw Code</h3>
        <section id="raw_code">
            <pre>
                <code>
(async () => {
    const loadScript = src => new Promise(resolve => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = resolve;
        document.head.appendChild(s);
    });
    
    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js');
    
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    
    let wakeLock = null;
    const requestWakeLock = async () => {
        try {
        if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
        }
        } catch (err) {}
    };
    
    const releaseWakeLock = async () => {
        try {
        if (wakeLock !== null) {
            await wakeLock.release();
            wakeLock = null;
        }
        } catch (err) {}
    };
    
    await requestWakeLock();
    
    document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'visible' && wakeLock === null) {
        await requestWakeLock();
        }
    });
    
    let galleryTitle = "";
    let totalPages = 0;
    
    const getPageCount = () => {
        try {
        const result = document.evaluate("/html/body/div/div/main/section/header/div[2]/div[2]/div[1]/a/span", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
        const span = result.singleNodeValue;
        return span ? parseInt(span.textContent.trim()) : 0;
        } catch (e) {
        return 0;
        }
    };
    
    const scrollToPageOne = async () => {
        let attempt = 0;
        const maxAttempts = 20;
        while (attempt < maxAttempts) {
        const img = document.querySelector('img[alt="Page 1"]');
        if (img) return img;
        window.scrollBy(0, 500);
        await delay(300);
        attempt++;
        }
        return null;
    };
    
    const waitForImageChange = async (previousSrc) => {
        const maxAttempts = 30;
        let attempt = 0;
        while (attempt < maxAttempts) {
        const img = document.querySelector('img.m-auto');
        if (img && img.src !== previousSrc && img.complete && img.naturalWidth > 10) return img;
        await delay(500);
        attempt++;
        }
        return null;
    };
    
    const clickRightHalf = (img) => {
        const rect = img.getBoundingClientRect();
        const x = rect.left + rect.width * 0.75;
        const y = rect.top + rect.height / 2;
        const clickEvent = new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        });
        img.dispatchEvent(clickEvent);
    };
    
    const convertBlobToFile = async (blobUrl, filename) => {
        const response = await fetch(blobUrl);
        const blob = await response.blob();
        return new File([await blob.arrayBuffer()], filename, { type: blob.type });
    };
    
    const scrapeAllPages = async () => {
        const titleXPath = "/html/body/div/div/main/section/header/div[2]/h1";
        const result = document.evaluate(titleXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
        const h1 = result.singleNodeValue;
        galleryTitle = h1 ? h1.textContent.trim().replace(/[<>:\"/\\|?*]+/g, '_') : "Untitled";
    
        totalPages = getPageCount();
        if (!totalPages || isNaN(totalPages) || totalPages < 1) return [];
    
        const startImg = await scrollToPageOne();
        if (!startImg) return [];
    
        startImg.click();
        await delay(1000);
    
        const imageSrcList = [];
        let previousSrc = '';
    
        while (imageSrcList.length < totalPages) {
        const img = await waitForImageChange(previousSrc);
        if (!img || imageSrcList.includes(img.src)) break;
        imageSrcList.push(img.src);
        previousSrc = img.src;
        await delay(500);
        clickRightHalf(img);
        await delay(900);
        }
    
        let retryCount = 0;
        while (imageSrcList.length < totalPages && retryCount < 10) {
        const currentImg = document.querySelector('img.m-auto');
        if (currentImg && !imageSrcList.includes(currentImg.src) && currentImg.complete && currentImg.naturalWidth > 10) {
            imageSrcList.push(currentImg.src);
        }
        await delay(1000);
        retryCount++;
        }
    
        return imageSrcList;
    };
    
    const downloadIndividually = async (imageUrls) => {
        for (let i = 0; i < imageUrls.length; i++) {
        const url = imageUrls[i];
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error ${response.status}`);
            const blob = await response.blob();
            saveAs(blob, `picture_${i + 1}.jpg`);
            await delay(600);
        } catch (e) {}
        }
    };
    
    const downloadAsZip = async (imageUrls, zipName = "gallery") => {
        if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') return;
        const zip = new JSZip();
        const folder = zip.folder(zipName);
        let fileCount = 0;
    
        for (let i = 0; i < imageUrls.length; i++) {
        const url = imageUrls[i];
        try {
            let file;
            const filename = `picture_${i + 1}.jpg`;
            if (url.startsWith('blob:')) {
            file = await convertBlobToFile(url, filename);
            } else {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error ${response.status}`);
            const blob = await response.blob();
            file = new File([blob], filename, { type: blob.type });
            }
            folder.file(file.name, file);
            fileCount++;
            await delay(400);
        } catch (e) {}
        }
    
        if (fileCount > 0) {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `${zipName}.zip`);
        }
    };
    
    const images = await scrapeAllPages();
    if (images.length !== totalPages) {
        alert(`Expected ${totalPages} pages but found ${images.length}. Download aborted.`);
    } else {
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        if (isMobile) {
        await downloadIndividually(images);
        } else {
        await downloadAsZip(images, galleryTitle);
        }
    }
    
    await releaseWakeLock();
    })();
    ch (e) {
        return 0;
        }
    };
    
    const scrollToPageOne = async () => {
        let attempt = 0;
        const maxAttempts = 20;
        while (attempt < maxAttempts) {
        const img = document.querySelector('img[alt="Page 1"]');
        if (img) return img;
        window.scrollBy(0, 500);
        await delay(300);
        attempt++;
        }
        return null;
    };
    
    const waitForImageChange = async (previousSrc) => {
        const maxAttempts = 20;
        let attempt = 0;
        while (attempt < maxAttempts) {
        const img = document.querySelector('img.m-auto');
        if (img && img.src !== previousSrc && img.complete && img.naturalWidth !== 0) return img;
        await delay(500);
        attempt++;
        }
        return null;
    };
    
    const clickRightHalf = (img) => {
        const rect = img.getBoundingClientRect();
        const x = rect.left + rect.width * 0.75;
        const y = rect.top + rect.height / 2;
        const clickEvent = new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        });
        img.dispatchEvent(clickEvent);
    };
    
    const convertBlobToFile = async (blobUrl, filename) => {
        const response = await fetch(blobUrl);
        const blob = await response.blob();
        return new File([await blob.arrayBuffer()], filename, { type: blob.type });
    };
    
    const scrapeAllPages = async () => {
        const titleXPath = "/html/body/div/div/main/section/header/div[2]/h1";
        const result = document.evaluate(titleXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
        const h1 = result.singleNodeValue;
        galleryTitle = h1 ? h1.textContent.trim().replace(/[<>:\"/\\|?*]+/g, '_') : "Untitled";
    
        totalPages = getPageCount();
        if (!totalPages || isNaN(totalPages) || totalPages < 1) return [];
    
        const startImg = await scrollToPageOne();
        if (!startImg) return [];
    
        startImg.click();
        await delay(1000);
    
        const imageSrcList = [];
        let previousSrc = '';
        let page = 1;
    
        while (true) {
        const img = await waitForImageChange(previousSrc);
        if (!img || imageSrcList.includes(img.src)) break;
        imageSrcList.push(img.src);
        previousSrc = img.src;
        await delay(400);
        clickRightHalf(img);
        await delay(900);
        page++;
        }
    
        return imageSrcList;
    };
    
    const downloadIndividually = async (imageUrls) => {
        for (let i = 0; i < imageUrls.length; i++) {
        const url = imageUrls[i];
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error ${response.status}`);
            const blob = await response.blob();
            saveAs(blob, `picture_${i + 1}.jpg`);
            await delay(600);
        } catch (e) {}
        }
    };
    
    const downloadAsZip = async (imageUrls, zipName = "gallery") => {
        if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') return;
        const zip = new JSZip();
        const folder = zip.folder(zipName);
        let fileCount = 0;
    
        for (let i = 0; i < imageUrls.length; i++) {
        const url = imageUrls[i];
        try {
            let file;
            const filename = `picture_${i + 1}.jpg`;
            if (url.startsWith('blob:')) {
            file = await convertBlobToFile(url, filename);
            } else {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error ${response.status}`);
            const blob = await response.blob();
            file = new File([blob], filename, { type: blob.type });
            }
            folder.file(file.name, file);
            fileCount++;
            await delay(400);
        } catch (e) {}
        }
    
        if (fileCount > 0) {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `${zipName}.zip`);
        }
    };
    
    const images = await scrapeAllPages();
    if (images.length !== totalPages) {
        alert(`Expected ${totalPages} pages but found ${images.length}. Download aborted.`);
    } else {
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        if (isMobile) {
        await downloadIndividually(images);
        } else {
        await downloadAsZip(images, galleryTitle);
        }
    }
    
    await releaseWakeLock();
    })();
                      


                </code>
            </pre>
        </section>

        <h3 id="readable_code_section">Readable Code</h3>
        <section>
            <pre id="readable_code">
                <code>
(async () => {
    const loadScript = src => new Promise(resolve => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = resolve;
        document.head.appendChild(s);
    });
    
    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js');
    
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
    
    let galleryTitle = ""; // Global title
    
    const waitForImageChange = async (previousSrc) => {
        const maxAttempts = 20;
        let attempt = 0;
        while (attempt < maxAttempts) {
        const img = document.querySelector('img.m-auto');
        if (img && img.src !== previousSrc && img.complete) return img;
        await delay(500);
        attempt++;
        }
        return null;
    };
    
    const clickRightHalf = (img) => {
        const rect = img.getBoundingClientRect();
        const x = rect.left + rect.width * 0.75;
        const y = rect.top + rect.height / 2;
    
        const clickEvent = new MouseEvent("click", {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        });
    
        img.dispatchEvent(clickEvent);
    };
    
    const scrapeAllPages = async (maxPages = 100) => {
        const xpath = "/html/body/div/div/main/section/header/div[2]/h1";
        const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
        const h1 = result.singleNodeValue;
        galleryTitle = h1 ? h1.textContent.trim().replace(/[<>:"/\\|?*]+/g, '_') : "Untitled";
    
        console.log("Gallery Title:", galleryTitle);
    
        const startImg = document.querySelector('img[alt="Page 1"]');
        if (!startImg) {
        console.error("No image with alt='Page 1' found.");
        return [];
        }
        startImg.click();
        await delay(800);
    
        const imageSrcList = [];
        let previousSrc = '';
        let page = 1;
    
        while (page <= maxPages) {
        const img = await waitForImageChange(previousSrc);
        if (!img) {
            console.log("Reached end or no new image found.");
            break;
        }
    
        console.log(`Page ${page}: ${img.src}`);
        imageSrcList.push(img.src);
        previousSrc = img.src;
    
        await delay(300);
        clickRightHalf(img);
        await delay(800);
        page++;
        }
    
        return imageSrcList;
    };
    
    const downloadAsZip = async (imageUrls, zipName = "gallery") => {
        if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
        console.error("JSZip or FileSaver not loaded.");
        return;
        }
    
        const zip = new JSZip();
        const folder = zip.folder(zipName);
    
        for (let i = 0; i < imageUrls.length; i++) {
        const url = imageUrls[i];
        try {
            const response = await fetch(url);
            const blob = await response.blob();
            const ext = blob.type.split('/')[1] || 'jpg';
            const fileName = `page-${String(i + 1).padStart(3, '0')}.${ext}`;
            folder.file(fileName, blob);
            console.log(`Added: ${fileName}`);
        } catch (e) {
            console.warn(`Failed to fetch: ${url}`, e);
        }
        }
    
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `${zipName}.zip`);
        console.log("Download started.");
    };
    
    const images = await scrapeAllPages();
    await downloadAsZip(images, galleryTitle);
    })();
                      
                      
                </code>
            </pre>
        </section>

        <h3 id="bookmark_section"> Bookmark</h3>
        <section id="bookmark">
            <pre>
                <code data-code="booklet">
javascript:(async function(){
    const res = await fetch('https://zap-09.github.io/Bookmarklet/sub-pages/nya.html');
    const html = await res.text();
    const container = document.createElement('div');
    container.innerHTML = html;
    const section = container.querySelector('#raw_code');
    if (section) {
        const code = section.textContent.trim();
        const wrappedCode = `(async () => { ${code} })();`;
        try {
        eval(wrappedCode);
        } catch (e) {
        alert("Error running code: " + e.message);
        console.error(e);
        }
    } else {
        alert("Script not found in <section id='raw_code'>.");
    })();                 

                </code>
            </pre>
        </section>
        <button id="copyButton">Copy</button>
    </main>
    <footer>
        <ul>
            <li>
        <a href="#">Back to top</a>
            </li>
        </ul>
    </footer>
</body>
</html>